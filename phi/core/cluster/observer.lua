---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Young.Z
--- DateTime: 2018/5/3 13:54
---
local ev = require("resty.worker.events")
local red = require("tools.redis")
local ngx_time_at = ngx.timer.at
local logger = ngx.log
local CRIT = ngx.CRIT
local ngx_time = ngx.time
local ipairs = ipairs
local cjson = require("cjson.safe")
local worker_id = ngx.worker.id
local CACHE_KEY_PREFIX = "phi:cluster:event:"
local MATCH = CACHE_KEY_PREFIX .. "*"
local PHI_EVENTS = require("core.constants").DICTS.PHI_EVENTS
local dict = ngx.shared[PHI_EVENTS]
--- 节点ID、抓取数据周期、最大抓取数量、当前时间序列
local node_id, delay, max

local serial_cache_key = CACHE_KEY_PREFIX .. "current_event_serial"
local get_current_event_serial = function()
    return dict.get(serial_cache_key)
end
local set_current_event_serial = function()
    return dict.set(serial_cache_key)
end

local log = function(...)
    logger(CRIT, ...)
end
local _ok, new_tab = pcall(require, "table.new")
if not _ok or type(new_tab) ~= "function" then
    new_tab = function()
        return {}
    end
end

local start_up_time
local _M = {}

function _M.post(source, event, data, unique, localEvent)
    -- 集群事件处理
    if not localEvent then

    end
    ev.post(source, event, data, unique)
end

local function fetchData()
    local res, err = red:scan(0, "MATCH", MATCH, "COUNT", max)
    if not err then
        local keys = res[2]
        red:init_pipeline(#keys)
        for _, k in ipairs(keys) do
            red:get(k)
        end
        res, err = self.db:commit_pipeline()
        if res then
            local result = new_tab(#keys, 0)
            for i, item_str in ipairs(res) do
                local item, e = cjson.decode(item_str)
                if item then
                    result[i] = item
                else
                    log("查询事件内容失败！err:", e)
                    -- key数据无效，删除之
                    red:delete(keys[i])
                end
            end
            return result
        end
    end
    return nil, err
end

--[[
events:{
    "source":"",
    "event":"",
    "data":"",
    "unique":"",
    "node_id":"",
    "timestamp":"",
    "id":""
}
]]
local function poll_event()
    -- 只使用一个worker处理集群事件
    if worker_id ~= 0 then
        return
    end

    local events, err = fetchData()
    if err then
        log("polling event failed！err:", err)
        local ok, err = ngx_time_at(delay, poll_event)
        if not ok then
            log("failed to start recurring polling timer: ", err)
        end
    end

    -- 处理集群事件
    for i, item in ipairs(events) do
        if events.id <= get_current_event_serial() then
            break
        end
        set_current_event_serial(events.id)
        ev.post(events.source, "cluster", {
            event = events.event,
            data = events.data,
            events.unique
        }, CACHE_KEY_PREFIX .. events.id)
    end
end

function _M.register(callback, source, ...)
    ev.register(callback, source, ...)
end

function _M:init()
    start_up_time = ngx_time()
end

return _M