---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Young.
--- DateTime: 2018/4/20 17:33
---
local stringx = require "pl.stringx"

local PATH_SEPARATOR = "/"
local assert = assert
local type = type
local str_split = stringx.split
local ends_with = stringx.endswith
local trim = stringx.strip
local fullMatch = true
local _M = {}

--local function trim(s)
--    return (s:gsub("^%s*(.-)%s*$", "%1"))
--end

local function matchStrings(pattern, path)
    -- /? /f
    if "?" == pattern then
        return #path == 1
        -- /* /foo
    elseif "*" == pattern then
        return true
    else
        -- /foo /foo
        return pattern == path
    end
end

function _M.match(pattern, path)
    assert(type(pattern) == "string", "pattern must be string")
    assert(type(path) == "string", "path must be string")
    pattern = trim(pattern)
    path = trim(path)
    if ((path[1] == PATH_SEPARATOR) ~= (pattern[1] == PATH_SEPARATOR)) then
        return false
    end

    local pattDirs = str_split(pattern, PATH_SEPARATOR)
    local pathDirs = str_split(path, PATH_SEPARATOR)

    local pattIdxStart = 1
    local pattIdxEnd = #pattDirs
    local pathIdxStart = 1
    local pathIdxEnd = #pathDirs

    -- 从前往后，匹配第一个**前的所有内容
    while pattIdxStart <= pattIdxEnd and pathIdxStart <= pathIdxEnd do
        local pattDir = pattDirs[pattIdxStart]
        if "**" == pattDir then
            break
        end
        if not matchStrings(pattDir, pathDirs[pathIdxStart]) then
            return false
        end
        pattIdxStart = pattIdxStart + 1
        pathIdxStart = pathIdxStart + 1
    end

    if pathIdxStart > pathIdxEnd then
        -- path结束
        if pattIdxStart > pattIdxEnd then
            -- pattern也结束，这里总是返回true
            return ends_with(pattern, PATH_SEPARATOR) == ends_with(path, PATH_SEPARATOR)
        end

        if not fullMatch then
            return true
        end
        -- pattern到达最后一位，pattern是*且path最后一位应是/时才能匹配
        if pattIdxStart == pattIdxEnd and pattDirs[pattIdxStart] == "*" and ends_with(path, PATH_SEPARATOR) then
            return true
        end
        -- pattern未结束，任何非**的pattern都不匹配
        for i = pattIdxStart, pattIdxEnd do
            if pattDirs[i] ~= "**" then
                return false
            end
        end
        return true
    elseif pattIdxStart > pattIdxEnd then
        -- path未结束，但是pattern已经结束，不匹配
        return false

    elseif (not fullMatch) and "**" == pattDirs[pattIdxStart] then
        -- 非全路径匹配的情况下，pattern中的**将匹配所有的path后缀
        return true
    end

    -- 从后向前匹配，匹配最后一个**后的所有内容
    while (pattIdxStart <= pattIdxEnd and pathIdxStart <= pathIdxEnd) do
        local pattDir = pattDirs[pattIdxEnd]
        if pattDir == "**" then
            break
        end
        if not matchStrings(pattDir, pathDirs[pathIdxEnd]) then
            return false
        end
        pattIdxEnd = pattIdxEnd - 1
        pathIdxEnd = pathIdxEnd - 1
    end

    if pathIdxStart > pathIdxEnd then
        -- path结束, 任何非**的pattern都不匹配
        for i = pattIdxStart, pattIdxEnd do
            if pattDirs[i] ~= "**" then
                return false;
            end
        end
        return true;
    end

    while (pattIdxStart ~= pattIdxEnd and pathIdxStart <= pathIdxEnd) do
        local patIdxTmp = -1;
        -- 跳过pattern头部的**，查找后一个**
        for i = pattIdxStart + 1, pattIdxEnd do
            if pattDirs[i] == "**" then
                patIdxTmp = i;
                break ;
            end
        end
        if patIdxTmp == pattIdxStart + 1 then
            -- '**/**' 情况, 视为**
            pattIdxStart = pattIdxStart + 1;
        else
            -- 从第一个**开始到下一个**之间的pattern长度
            local patLength = (patIdxTmp - pattIdxStart - 1);
            -- 剩余path长度
            local strLength = (pathIdxEnd - pathIdxStart + 1);
            local foundIdx = -1;

            -- path剩余长度大于或等于pattern长度时，此时的path中至少会有一段完全匹配pattern
            for i = 0, strLength - patLength do
                local breakStrLoop
                -- 比较是否能和pattern完全匹配
                for j = 0, patLength - 1 do
                    local subPat = pattDirs[pattIdxStart + j + 1];
                    local subStr = pathDirs[pathIdxStart + i + j];
                    if not matchStrings(subPat, subStr) then
                        breakStrLoop = true
                        break
                    end
                end
                if not breakStrLoop then
                    -- 记录全匹配时的idx
                    foundIdx = pathIdxStart + i;
                    break ;
                end
            end

            -- 未找到则不匹配
            if (foundIdx == -1) then
                return false;
            end

            pattIdxStart = patIdxTmp;
            pathIdxStart = foundIdx + patLength;
        end
    end

    for i = pattIdxStart, pattIdxEnd do
        if pattDirs[i] ~= "**" then
            return false;
        end
    end

    return true;
end

function _M:new(fullMatch)
    return setmetatable({ fullMatch = fullMatch }, { __index = _M })
end

return _M