---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Young.
--- DateTime: 2018/4/20 17:33
---
local stringx = require "pl.stringx"

local PATH_SEPARATOR = "/"
local assert = assert
local type = type
local str_split = stringx.split
local ends_with = stringx.endswith
local trim = stringx.strip
local fullMatch = true
local _M = {}

--local function trim(s)
--    return (s:gsub("^%s*(.-)%s*$", "%1"))
--end

local function matchStrings(pattern, path)
    -- /? /foo
    if "?" == pattern then
        return #path == 1
        -- /* /foo
    elseif "*" == pattern then
        return true
    else
        -- /foo /foo
        return pattern == path
    end
end

function _M.match(pattern, path)
    assert(type(pattern) == "string", "pattern must be string")
    assert(type(path) == "string", "path must be string")
    pattern = trim(pattern)
    path = trim(path)
    if ((path[1] == PATH_SEPARATOR) ~= (pattern[1] == PATH_SEPARATOR)) then
        return false
    end

    local pattDirs = str_split(pattern, PATH_SEPARATOR)
    local pathDirs = str_split(path, PATH_SEPARATOR)

    local pattIdxStart = 1
    local pattIdxEnd = #pattDirs
    local pathIdxStart = 1
    local pathIdxEnd = #pathDirs

    -- 匹配第一个**前的所有内容
    while pattIdxStart <= pattIdxEnd and pathIdxStart <= pathIdxEnd do
        local pattDir = pattDirs[pattIdxStart]
        if "**" == pattDir then
            break
        end
        if not matchStrings(pattDir, pathDirs[pathIdxStart]) then
            return false
        end
        pattIdxStart = pattIdxStart + 1
        pathIdxStart = pathIdxStart + 1
    end

    if pathIdxStart > pathIdxEnd then
        -- Path is exhausted, only match if rest of pattern is * or **'s
        if pattIdxStart > pattIdxEnd then
            return ends_with(pattern, PATH_SEPARATOR) == ends_with(path, PATH_SEPARATOR)
        end

        if not fullMatch then
            return true
        end

        if pattIdxStart == pattIdxEnd and pattDirs[pattIdxStart] == "*" and ends_with(path, PATH_SEPARATOR) then
            return true
        end

        for i = pattIdxStart, pattIdxEnd do
            if pattDirs[i] ~= "**" then
                return false
            end
        end
        return true
    elseif pattIdxStart > pattIdxEnd then
        -- String not exhausted, but pattern is. Failure.
        return false

    elseif (not fullMatch) and "**" == pattDirs[pattIdxStart] then
        -- Path start definitely matches due to "**" part in pattern.
        return true
    end
    -- up to last '**'
    while (pattIdxStart <= pattIdxEnd and pathIdxStart <= pathIdxEnd) do
        local pattDir = pattDirs[pattIdxEnd]
        if pattDir == "**" then
            break
        end
        if not matchStrings(pattDir, pathDirs[pathIdxEnd]) then
            return false
        end
        pattIdxEnd = pattIdxEnd - 1
        pathIdxEnd = pathIdxEnd - 1
    end

    if pathIdxStart > pathIdxEnd then
        -- String is exhausted
        for i = pattIdxStart, pattIdxEnd do
            if pattDirs[i] ~= "**" then
                return false;
            end
        end
        return true;
    end

    while (pattIdxStart ~= pattIdxEnd and pathIdxStart <= pathIdxEnd) do
        local patIdxTmp = -1;
        for i = pattIdxStart + 1, pattIdxEnd do
            if pattDirs[i] == "**" then
                patIdxTmp = i;
                break ;
            end
        end
        if patIdxTmp == pattIdxStart + 1 then
            -- '**/**' situation, so skip one
            pattIdxStart = pattIdxStart + 1;
        else
            -- Find the pattern between padIdxStart & padIdxTmp in str between
            -- strIdxStart & strIdxEnd
            local patLength = (patIdxTmp - pattIdxStart - 1);
            local strLength = (pathIdxEnd - pathIdxStart + 1);
            local foundIdx = -1;

            for i = 1, strLength - patLength do
                local breakStrLoop
                for j = 1, patLength do
                    local subPat = pattDirs[pattIdxStart + j + 1];
                    local subStr = pathDirs[pathIdxStart + i + j];
                    if not matchStrings(subPat, subStr) then
                        breakStrLoop = true
                        break
                    end
                end
                if not breakStrLoop then
                    foundIdx = pathIdxStart + i;
                    break ;
                end
            end

            if (foundIdx == -1) then
                return false;
            end

            pattIdxStart = patIdxTmp;
            pathIdxStart = foundIdx + patLength;
        end
    end

    for i = pattIdxStart, pattIdxEnd do
        if pattDirs[i] ~= "**" then
            return false;
        end
    end

    return true;
end

function _M:new(fullMatch)
    return setmetatable({ fullMatch = fullMatch }, { __index = _M })
end

return _M